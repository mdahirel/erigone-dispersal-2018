---
title: "Erigone project 2018 - script"
author: - "**Maxime Dahirel** (script author)"
date:
output: 
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## **Introduction**

The aims of this study were to:

*to add*

## **Starters and data wrangling**

*to complete*

```{r load-packages}
library(arm)
library(matrixStats)

## spatial stuff
#library(ggmap) #still needed?? not sure
library(ggspatial)
library(osmdata)
library(sf)

## pedigree stuff (still needed??)
library(nadiv)

library(cmdstanr) ## Stan backend
library(brms) ## the interface we are using
library(tidyverse)
library(bayesplot)
library(ggdist)
library(tidybayes)
library(ggtext)
library(patchwork) #plotting
library(lubridate) ## conflict with here

library(here)

options(mc.cores = 4)
```

let's load the main data:

```{r load-raw-datafiles}
## Load raw datasets
data_main <- read_csv(here("data","erigone2018_females2.csv"),
                      col_types = cols(sex=col_character())) %>%  
  ##only females "F", so if col_types not given explicitly, "sex" column is parsed as logical
            filter(generation > 0) # we only keep lab-born spiders for this analysis

###NOTE to round sizes to nearest 0.1mm, with clear indication that raw-raw data are "more precise" but that's just artifact from 
## measurement software


data_mothers <- read_csv(here("data","erigone2018_females.csv"),
                      col_types = cols(sex=col_character())) %>%
            filter(generation <2) %>% 
  select(MOTHER= ID,
         CT_length1_mom = CT_length1,
         CT_length2_mom = CT_length1,
         CT_width1_mom = CT_width1,
         CT_width2_mom = CT_width2
         )

data_clutches <- read_csv(here("data","erigone2018_cocoons.csv"))

pedigree <- read_csv(here("data","erigone2018_pedigree.csv"))

sites <- read_csv(here("data","erigone2018_sites.csv"))

pairings <- read_csv(here("data","erigone2018_pairings.csv"))

## see later for environmental data, and male data
```

now let's load what we need for maps:

```{r}
points<-st_read(here("data","erigone2018_GISlayers.gpkg"),
        layer="sampling_sites")

patches<-st_read(here("data","erigone2018_GISlayers.gpkg"),
        layer="habitat_type") %>% 
  st_make_valid() ##possible problem of invalid geometry

coastline<-st_read(here("data","erigone2018_GISlayers.gpkg"),
        layer="coastline")
```

this the code chunk for fig 1, ie the map: (to clean)

```{r}

patches_updated <- patches %>% 
         filter(!is.na(plant)) %>% 
         mutate(plant=fct_relevel(plant,c("puccinellia_dominant",
                                          "puccinellia_partial"),after=0)) %>% 
         mutate(`habitat type`=fct_recode(plant,
                                        `*Puccinellia maritima* dominant` = "puccinellia_dominant",
                                        `*Puccinellia maritima* present` = "puccinellia_partial",
                                        `other unfavourable land` = "other"))

points_updated <- points %>% 
  mutate(`*E. longipalpis* found?` = fct_recode(factor(has.spider),
                                                "yes"="1",
                                                "no"="0")
  )

### a general map of western europe
plot_1a <- ggplot() +
  geom_sf(data=coastline)+
    geom_sf(data=points_updated[1,],pch=19,size=3)+
  coord_sf(xlim=c(-10.854,11.074),ylim=c(41.925,55.653))+
  theme_bw()+
  theme(
        panel.background = element_rect(fill="lightblue"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())

### the map of the study site
plot_1b <- ggplot(data = patches_updated) +
    geom_sf(aes(fill = `habitat type`,col=`habitat type`)) + 
    geom_sf(data=points_updated,aes(pch=`*E. longipalpis* found?`),size=3)+
    scale_fill_manual(values=c("#238443","#addd8e","#ffffe5"))+
    scale_colour_manual(values=c("#238443","#addd8e","#ffffe5"),
                        guide=guide_legend(override.aes = list(col="black")))+
  ##colors based on the YlGn palette in ColorBrewer
    scale_shape_manual(values=c(21,19))+
      annotation_scale(location = "br") + # ggspatial scale on bottom left
    annotation_north_arrow(location = "tr",
                           style = north_arrow_fancy_orienteering) + # ggspatial arrow on top right
  coord_sf(xlim=c(-1.63,-1.47),
           ylim=c(48.615,48.655))+
  theme_bw()+
  theme(legend.position = "bottom",
        legend.text=element_markdown(),
        legend.title=element_markdown(),
        panel.background = element_rect(fill="lightblue"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())



((plot_1a+plot_1b +
  plot_layout(widths = c(1, 4)))&
  theme(legend.position = "bottom",
        legend.box="vertical", 
        legend.box.just = 1))
```


this is some quality checks for the Methods

```{r}
read_csv(here("data","erigone2018_females.csv"),
                      col_types = cols(sex=col_character())) %>%  ##only females "F", if not given, will parse as logical
            filter(generation == 0) %>% 
  select(captured_on) %>% 
  distinct()

## field days are April 12, 13, May 4, May 9

## a quick confirmation of field notes that sampling was done in sunny weather
read_csv(here("data","weather_data","pontorson_meteonet_2018.csv")) %>% 
 filter(yday(date) %in% yday(ymd(c("2018-04-12","2018-04-13","2018-05-04","2018-05-09")))) %>% 
  mutate(was_sampling=hour(date)>9 & hour(date)<18) %>% #sampling was between 10pm and 5pm actually, so larger margin
 group_by(yday(date),was_sampling) %>% 
 summarise(rain=sum(precip))

## no rain indeed during sampling period
```


more checks

```{r}
pedigree %>% filter(generation>0) %>% group_by(sex) %>% count()

# counting the number of adults in the lab

sum(data_clutches$N_spiderlings) # total number of spiderlings hatched in lab


sum(sites$N_adult_females) # number of females caught total

sites %>% group_by(landscape,is_habitat) %>% 
  summarise(N_patches_with_spiders=sum(N_adult_females>0),
            N_patches_total=n())

## number of wild females that produced cocoons and babies
data_clutches %>% 
  mutate(animal=ID) %>% 
  left_join(pedigree) %>% 
  filter(generation==0) %>% 
  group_by(ID) %>% 
  summarise(had_cocoons=max(N_cocoons>0),had_babies=max(N_spiderlings>0)) %>% 
  summarise(N_with_cocoons=sum(had_cocoons),N_with_babies=sum(had_babies))
  
  
pedigree %>% filter(generation>0) %>% group_by(sex) %>% count()

# counting the number of adults in the lab


pedigree %>% group_by(sex,generation) %>% count()

pedigree %>% 
  select(MOTHER,FATHER) %>% distinct() %>% ##keep all unique MOTHER/FATHER pairs
  filter(is.na(FATHER)==FALSE) %>% 
  group_by(FATHER) %>% summarise(N_uses_per_male=length(FATHER)) %>%
  summarise(median=median(N_uses_per_male),
            mean=mean(N_uses_per_male),
            percent_more_than_one=mean(N_uses_per_male>1),
            min=min(N_uses_per_male),max=max(N_uses_per_male))
####mmm_but this is only for the ones that were kept to adults.
#### did we keep that info for the eggs???

### the version for all matings
pairings %>% 
  filter(is.na(mateID)==FALSE) %>% 
  group_by(mateID) %>% summarise(N_uses_per_male=length(mateID)) %>%
  summarise(median=median(N_uses_per_male),
            mean=mean(N_uses_per_male),
            percent_more_than_one=mean(N_uses_per_male>1),
            min=min(N_uses_per_male),max=max(N_uses_per_male))



sum(is.na(data_main$date_mating))

```


our choice of life history metrics is inspired (but not 100% identical) to Healy et al 2019 NEE:

- Age at maturity
- Adult longevity
- Fecundity

We add to that

- body size information
- dispersal information (presence/absence of dispersal-related behaviours; rappelling frequencies).

```{r data-wrangling-1}
fecundity <- data_clutches %>% 
  group_by(ID) %>% 
  summarise(lifetime_fecundity=sum(N_spiderlings),
            N_cocoons=sum(N_cocoons),
            N_cocoons_hatched=sum(Cocoon_hatched))


data <- left_join(data_main,fecundity) %>%
  mutate(animal = ID) %>% 
  left_join(pedigree) %>% 
  mutate(lifetime_fecundity=replace_na(lifetime_fecundity,0), 
         ###individuals with no record in the fecundity are not NA, they failed to reproduce
         ### but in some cases it may be beccause no mating; we'll account for that in analysis
         N_cocoons=replace_na(N_cocoons,0),
         N_cocoons_hatched=replace_na(N_cocoons_hatched,0),
         N_rappelling=replace_na(N_rappelling,0),
         N_other_tiptoe=replace_na(N_other_tiptoe,0),
         ## we do the same for rappelling, a few NA because died before dispersal
         ## but for some downstream methods we need something with no NAs
         ## so dummy variables
         ) %>% 
  mutate(time_to_maturity = (ymd(date_maturity)-ymd(date_hatching)) %>%  as.numeric(),
         adult_longevity = (ymd(date_death)-ymd(date_maturity)) %>%  as.numeric()
         ) %>% 
  mutate(generation = factor(generation),
         clutchID = paste(MOTHER,"-",as.character(date_egg),sep="")###wild are assumed to not be direct siblings, all count as their own clutch
  ) %>% 
  mutate(obsgap_maturity=case_when(date_maturity=="2018-05-22" | date_egg=="2018-05-22" ~ "yes",
                             wday(date_maturity,week_start=1)==1 | wday(date_egg,week_start=1)==1 ~ "yes",
                             date_maturity=="2018-05-02" | date_egg== "2018-05-02" |
                               date_maturity=="2018-05-09" | date_egg=="2018-05-09" ~ "yes",
                             T~ "no")) %>% 
  mutate(obsgap_longevity=case_when(date_maturity=="2018-05-22" | date_death=="2018-05-22" ~ "yes",
                             wday(date_maturity,week_start=1)==1 | wday(date_death,week_start=1)==1 ~ "yes",
                             date_maturity=="2018-05-02" | date_death== "2018-05-02" |
                               date_maturity=="2018-05-09" | date_death=="2018-05-09" ~ "yes",
                             T~ "no"))

## we add variables that say whether or not one of the two observations that govern phase duration
## were made right after a gap in observation (WE, holdays, other)
## leading to potential bias

```

```{r general-model-trialversion}
data$adult_censored <- (data$outlived_experiment==TRUE | data$accidental_death==TRUE)
data$time_for_repro=as.numeric(ymd(data$date_death)-ymd(data$date_mating))
data$had.mate<- (is.na(data$date_mating)==FALSE)
```

```{r}
temp_length<- data %>%
  select(ID,CT_length1,CT_length2) %>% 
  pivot_longer(cols=c(CT_length1,CT_length2),
               names_to = "size_measurement",
               names_prefix="CT_length",
               values_to="CT_length") 

temp_width<- data %>%
  select(ID,CT_width1,CT_width2) %>% 
  pivot_longer(cols=c(CT_width1,CT_width2),
               names_to = "size_measurement",
               names_prefix="CT_width",
               values_to="CT_width") 

temp_size=left_join(temp_length,temp_width)

data<-data %>% 
  select(-c(CT_length1,CT_length2,CT_width1,CT_width2)) %>% 
  left_join(temp_size) %>% 
  mutate(s_CT_width=scale(CT_width)[,1],
         s_CT_length=scale(CT_length)[,1]) %>% 
  mutate(landscape=fct_relevel(landscape,"west",after=0))
## we re-order so west is left in plots like in maps

```

more checks for methods
```{r}
mean(data$date_mating-data$date_maturity,na.rm=TRUE)
sd(data$date_mating-data$date_maturity,na.rm=TRUE)
range(as.numeric(data$date_mating-data$date_maturity),na.rm=TRUE)

 sum(data$outlived_experiment)# how many right censored
 
 sum(is.na(data$N_rappelling)& data$size_measurement==1)
 
 sum(!is.na(data$CT_width) & data$size_measurement==1) ## how many females measured
 
  sum(!is.na(data$date_mating) & data$time_for_repro>0 & data$size_measurement==1)
```

# models


let's analyse population densities

```{r}
sites<-sites %>% 
  mutate(landscape=fct_relevel(landscape,"west",after=0))
```

the main model, includig only "true" habitat
```{r}
if (file.exists(here("R_output", "mod_popsize.Rdata"))) {
  # this if-else statement is avoid re-fitting a model if there is already one existing in R_output
  # to override, re-run the model and re-save manually by selecting only the relevant code lines (or delete the Rdata object before relaunching this code chunk)
  load(here("R_output", "mod_popsize.Rdata"))
} else {
mod_pop <- brm(
  N_adult_females|rate(person_hours_on_patch)~
    landscape,family=poisson,
  data=subset(sites, is_habitat=="y"),
  prior=c(
    set_prior("normal(0,1)",class="Intercept"),
    set_prior("normal(0,1)",class="b")
  ),
        iter=6000,warmup=3000,chains=4,
        seed=42,
        backend="cmdstanr"
)
  save(list = c("mod_pop"), file = here("R_output", "mod_popsize.Rdata"))
}
```

```{r}
if (file.exists(here("R_output", "mod_popsize_suppl.Rdata"))) {
  # this if-else statement is avoid re-fitting a model if there is already one existing in R_output
  # to override, re-run the model and re-save manually by selecting only the relevant code lines (or delete the Rdata object before relaunching this code chunk)
  load(here("R_output", "mod_popsize_suppl.Rdata"))
} else {
mod_pop_suppl <- brm(
  N_adult_females|rate(person_hours_on_patch)~
    landscape,family=poisson,
  data=sites,
  prior=c(
    set_prior("normal(0,1)",class="Intercept"),
    set_prior("normal(0,1)",class="b")
  ),
        iter=6000,warmup=3000,chains=4,
        seed=42,
        backend="cmdstanr"
)
  save(list = c("mod_pop_suppl"), file = here("R_output", "mod_popsize_suppl.Rdata"))
}
```


a draft of the figure

```{r}
newdata_pop<-sites %>% 
  filter(is_habitat=="y") %>% 
  select(landscape) %>% 
  distinct() %>% 
  mutate(person_hours_on_patch=1) %>% 
  add_epred_draws(mod_pop)
  
plot2<-ggplot()+
  stat_eye(data=newdata_pop,aes(landscape,.epred),
           slab_alpha=0.5,
           fill="#238443",
           .width=c(0.001,0.95),
           point_interval="mean_hdi")+
  geom_jitter(data=sites %>% filter(is_habitat=="y"),aes(landscape,N_adult_females/person_hours_on_patch),
              position=position_jitter(width=0.2),pch=21,size=2,fill="white")+
  scale_x_discrete("landscape of origin")+
  scale_y_continuous("Population density (female *E. longipalpis* per person-hour)")+
  theme_bw()+
  theme(axis.title.y = element_markdown())

plot2
```


first a model for the phenotypic correlation:

we notes the "valid" points for each variable (for the subset)(mostly involve avoiding duplicates for non size variables, but not only)
```{r}
data$is.valid_dispersal=as.numeric(data$size_measurement==1 & 
                            data$natural_death_before_dispersal==0)

data$is.valid_maturity=as.numeric(data$size_measurement==1)

data$is.valid_fecundity=as.numeric(data$time_for_repro>0 & 
                                     data$had.mate ==TRUE &  ## so we exclude all unmated spiders and spiders that did not have time to lay eggs
                            data$size_measurement==1)

data$is.valid_longevity=as.numeric(data$size_measurement==1)
```


```{r}
bf_size<-bf(s_CT_width |mi() ~   ## use in-model imputation
              landscape +                     ## interpatch variation, fixed component
             (1|patch)+                       ## interpatch variation, random component
             (1|r|ID),                        ## within-patch individual (co)variation
             family=gaussian)

bf_dispersal<-bf(N_rappelling2 | 
                   subset(is.valid_dispersal) ~ ## data is doubled due to putting size in the "long format"
                                                 ## we only use one value per individual here, to avoid artificial doubling of N  
                   landscape + 
                   (1|patch)+
                   (1|r|ID),
                 family=poisson)

bf_devtime<-bf(time_to_maturity | 
                 subset(is.valid_maturity) ~ 
                 landscape + 
                 obsgap_maturity +              ## we include this as a covariate to control whether obs gaps bias our times
             (1|patch)+
             (1|r|ID),family=poisson)

bf_longevity<-bf(adult_longevity|
                   cens(adult_censored) +   ## some individuals were not observed until the end of their natural lifespan (accidental loss/killing or outlived the experiment)
                   subset(is.valid_longevity) ~ 
                   landscape + 
                   obsgap_longevity +
             (1|patch)+
             (1|r|ID),family=poisson)


bf_fecundity<-bf(lifetime_fecundity|
                   rate(time_for_repro) + ### we analysed the productivity (N offspring per day available to lay eggs)
                   subset(is.valid_fecundity) ~ 
                   landscape + 
             (1|patch)+
             (1|r|ID),family=poisson)
```


```{r}
prior<-c(
  set_prior("normal(0,1)",class="Intercept",resp=c("Nrappelling2","sCTwidth","lifetimefecundity")),
  set_prior("normal(3.4,1)",class="Intercept",resp=c("timetomaturity","adultlongevity")),
  ### bonte pnas and duffey (longipalpis) suggest a month (exp(3.4)) is a good ballpark prior
  set_prior("normal(0,1)",class="b",resp=c("Nrappelling2","lifetimefecundity","sCTwidth")),
  set_prior("normal(0,1)",class="b",resp=c("timetomaturity","adultlongevity")),
  set_prior("normal(0,1)",class="sd",resp=c("Nrappelling2","timetomaturity","lifetimefecundity","adultlongevity","sCTwidth")),
  set_prior("lkj(3)",class="cor")
)
```


```{r}
if (file.exists(here("R_output", "multivar_mod_1.Rdata"))) {
  # this if-else statement is avoid re-fitting a model if there is already one existing in R_output
  # to override, re-run the model and re-save manually by selecting only the relevant code lines (or delete the Rdata object before relaunching this code chunk)
  load(here("R_output", "multivar_mod_1.Rdata"))
} else {
  
mmod1=brm(mvbf(bf_dispersal+bf_devtime+bf_fecundity+bf_longevity+bf_size),
        data=data,
        iter=6000,warmup=3000,chains=4,
        prior=prior,
        control=list(adapt_delta=0.99,max_treedepth=15),
        seed=42,
        backend="cmdstanr")

  save(list = c("mmod1"), file = here("R_output", "multivar_mod_1.Rdata"))
}
```


a draft of the figure
```{r}

newdata_maturity<-data %>% 
  select(landscape) %>% 
  distinct() %>% 
  mutate(is.valid_maturity=1, obsgap_maturity="no") %>% 
  add_epred_draws(mmod1,resp="timetomaturity",re_formula = NA)

plot3_a<-ggplot()+
  geom_boxplot(data=subset(data,is.valid_maturity==1),
               aes(landscape,time_to_maturity, group=patch),col="grey50")+
  stat_eye(data=newdata_maturity,aes(landscape,.epred),
           slab_alpha=0.5,
           fill="#238443",
           .width=c(0.001,0.95),
           point_interval="mean_hdi")+
  scale_x_discrete("")+
  scale_y_continuous("Age at maturity (days)")

newdata_size<-data %>% 
  select(landscape) %>% 
  distinct() %>%  
  add_epred_draws(mmod1,resp="sCTwidth",re_formula = NA) %>% 
  mutate(.epred=(.epred*sd(data$CT_width,na.rm=TRUE))+mean(data$CT_width,na.rm=TRUE))
# we back transform the predictions from scaled values to observed

plot3_b<-ggplot()+
  geom_boxplot(data=data,aes(landscape,CT_width, group=patch),col="grey50")+
  stat_eye(data=newdata_size,aes(landscape,.epred),
           slab_alpha=0.5,
           fill="#238443",
           .width=c(0.001,0.95),
           point_interval="mean_hdi")+
  scale_x_discrete("")+
  scale_y_continuous("Adult size (cephalothorax width, mm)")

newdata_dispersal<-data %>% 
  select(landscape) %>% 
  distinct() %>% 
  mutate(is.valid_dispersal=1) %>% 
  add_epred_draws(mmod1,resp="Nrappelling",re_formula = NA)

plot3_c<-ggplot()+
  geom_boxplot(data=subset(data,is.valid_dispersal==1),
               aes(landscape,N_rappelling, group=patch),col="grey50")+
  stat_eye(data=newdata_dispersal,aes(landscape,.epred),
           slab_alpha=0.5,
           fill="#238443",
           .width=c(0.001,0.95),
           point_interval="mean_hdi")+
  scale_x_discrete("")+
  scale_y_continuous("Dispersal (# rappelling attempts)")

newdata_fecundity<-data %>% 
  select(landscape) %>% 
  distinct() %>% 
  mutate(is.valid_fecundity=1,time_for_repro=1) %>% 
  add_epred_draws(mmod1,resp="lifetimefecundity",re_formula = NA)

plot3_d<-ggplot()+
  geom_boxplot(data=subset(data,is.valid_fecundity==1),
               aes(landscape,lifetime_fecundity/time_for_repro, group=patch),col="grey50")+
  stat_eye(data=newdata_fecundity,aes(landscape,.epred),
           slab_alpha=0.5,
           fill="#238443",
           .width=c(0.001,0.95),
           point_interval="mean_hdi")+
  scale_x_discrete("landscape of origin")+
  scale_y_continuous("Fecundity (# offspring/day)")


newdata_longevity<-data %>% 
  select(landscape) %>% 
  distinct() %>% 
  mutate(is.valid_longevity=1,obsgap_longevity="no") %>% 
  add_epred_draws(mmod1,resp="adultlongevity",re_formula = NA)

plot3_e<-ggplot()+
  geom_boxplot(data=subset(data,is.valid_longevity==1),
               aes(landscape,adult_longevity, group=patch),col="grey50")+
  stat_eye(data=newdata_longevity,aes(landscape,.epred),
           slab_alpha=0.5,
           fill="#238443",
           .width=c(0.001,0.95),
           point_interval="mean_hdi")+
  scale_x_discrete("")+
  scale_y_continuous("Adult longevity (days)")


layout <- "
AB#
CDE
"
plot3_a+plot3_b+plot3_c+plot3_d+plot3_e + 
  plot_layout(design = layout) & theme_bw()
```



then a model where we split this into "relatedness + common environment" and residual (or within and among families, in the parlance of lynch walsh):

we cannot go further and include father info since it is missing for G1, and we cannot assume that wild caught females only mated with one male (which would allow us to add these phantom males to the pedigree) since there is indication that erigone females mate multiple times (anecdote in de meester bonte 2010 among others,see also Comparative  study  of  courtship  and  copulation  in  fiveOedothorax species)

```{r}
bf_size2<-bf(s_CT_width |mi() ~   ## use in-model imputation
              landscape +                     ## interpatch variation, fixed component
             (1|patch)+                       ## interpatch variation, random component
              (1|q|MOTHER)+
             (1|r|ID),                        ## within-patch individual (co)variation
             family=gaussian)

bf_dispersal2<-bf(N_rappelling2 |
                   subset(is.valid_dispersal==1) ~ ## data is doubled due to putting size in the "long format"
                                                 ## we only use one value per individual here, to avoid artificial doubling of N  
                   landscape + 
                   (1|patch)+
                   (1|q|MOTHER)+
                   (1|r|ID),
                 family=poisson)

bf_devtime2<-bf(time_to_maturity | 
                 subset(is.valid_maturity==1) ~ 
                 landscape + 
                 obsgap_maturity +              ## we include this as a covariate to control whether obs gaps bias our times
             (1|patch)+
               (1|q|MOTHER)+
             (1|r|ID),family=poisson)

bf_longevity2<-bf(adult_longevity|
                   cens(adult_censored) +   ## some individuals were not observed until the end of their natural lifespan (accidental loss/killing or outlived the experiment)
                   subset(is.valid_longevity==1) ~ 
                   landscape + 
                   obsgap_longevity +
             (1|patch)+
               (1|q|MOTHER)+
             (1|r|ID),family=poisson)


bf_fecundity2<-bf(lifetime_fecundity|
                   rate(time_for_repro) + ### we analysed the productivity (N offspring per day available to lay eggs)
                   subset(is.valid_fecundity==1) ~ 
                   landscape + 
             (1|patch)+
               (1|q|MOTHER)+
             (1|r|ID),family=poisson)

```


```{r}
if (file.exists(here("R_output", "multivar_mod_2.Rdata"))) {
  # this if-else statement is avoid re-fitting a model if there is already one existing in R_output
  # to override, re-run the model and re-save manually by selecting only the relevant code lines (or delete the Rdata object before relaunching this code chunk)
  load(here("R_output", "multivar_mod_2.Rdata"))
} else {
  
mmod2=brm(mvbf(bf_dispersal2+bf_devtime2+bf_fecundity2+bf_longevity2+bf_size2),
        data=data,
        iter=6000,warmup=3000,chains=4,
        prior=prior,
        control=list(adapt_delta=0.99,max_treedepth=20),
        seed=42,
        backend="cmdstanr")


  save(list = c("mmod2"), file = here("R_output", "multivar_mod_2.Rdata"))
}
```

we find that most of the syndrome is driven by within-family variation (something that would not have been visible from the attempt at doing an animal model)



### the correlation tables


```{r}
summary_mod_pop <- mod_pop %>%
  as_draws_df() %>%
  select(starts_with(c("b_"))) %>%
  pivot_longer(everything()) %>%
  group_by(name) %>%
  mean_hdi()

summary_mod_pop

summary_mmod1 <- mmod1 %>%
  as_draws_df() %>%
  select(starts_with(c("b_", "sd_", "cor_ID", "sigma"))) %>%
  pivot_longer(everything()) %>%
  group_by(name) %>%
  mean_hdi() 

summary_mmod1 %>% 
  print(n=Inf)

## let's look at the Beta coeffs:
summary_mmod1 %>% 
  filter(substr(name,1,2)=="b_")


summary_mmod2 <- mmod2 %>%
  as_draws_df() %>%
  select(starts_with(c("b_", "sd_", "cor_ID","cor_MOTHER", "sigma"))) %>%
  pivot_longer(everything()) %>%
  group_by(name) %>%
  mean_hdi() 

summary_mmod2 %>% 
  print(n=Inf)

## let's look at the Beta coeffs:
summary_mmod2 %>% 
  filter(substr(name,1,2)=="b_")
```


```{r}
table_cor_fullIND<-summary_mmod1 %>% 
  mutate(value = paste(round(value,2)," [", round(.lower,2),"; ",round(.upper,2),"]",sep="")) %>% 
  filter(str_detect(name,"cor_ID")==TRUE) %>% 
  mutate(response1 = case_when(
    str_detect(name,"cor_ID__adultlongevity") ~ "Adult longevity",
    str_detect(name, "cor_ID__lifetimefecundity") ~ "Fecundity",
    str_detect(name, "cor_ID__Nrappelling") ~ "Dispersal",
    str_detect(name,"cor_ID__timetomaturity") ~ "Time to maturity",
    str_detect(name,"cor_ID__sCTwidth") ~ "Body size"),
         response2 = case_when(
    str_detect(name,"adultlongevity_Intercept$") ~ "Adult longevity",
    str_detect(name, "lifetimefecundity_Intercept$") ~ "Fecundity",
    str_detect(name, "Nrappelling_Intercept$") ~ "Dispersal",
    str_detect(name,"timetomaturity_Intercept$") ~ "Time to maturity",
    str_detect(name,"sCTwidth_Intercept$") ~ "Body size"),
  ) %>% 
  select(response1,response2,value) 



table_cor_MOTHER<-summary_mmod2 %>% 
  mutate(value = paste(round(value,2)," [", round(.lower,2),"; ",round(.upper,2),"]",sep="")) %>% 
  filter(str_detect(name,"cor_MOTHER")==TRUE) %>% 
  mutate(response1 = case_when(
    str_detect(name,"cor_MOTHER__adultlongevity") ~ "Adult longevity",
    str_detect(name, "cor_MOTHER__lifetimefecundity") ~ "Fecundity",
    str_detect(name, "cor_MOTHER__Nrappelling") ~ "Dispersal",
    str_detect(name,"cor_MOTHER__timetomaturity") ~ "Time to maturity",
    str_detect(name,"cor_MOTHER__sCTwidth") ~ "Body size"),
         response2 = case_when(
    str_detect(name,"adultlongevity_Intercept$") ~ "Adult longevity",
    str_detect(name, "lifetimefecundity_Intercept$") ~ "Fecundity",
    str_detect(name, "Nrappelling_Intercept$") ~ "Dispersal",
    str_detect(name,"timetomaturity_Intercept$") ~ "Time to maturity",
    str_detect(name,"sCTwidth_Intercept$") ~ "Body size"),
  ) %>% 
  select(response1,response2,value) 

table_cor_ID<-summary_mmod2 %>% 
  mutate(value = paste(round(value,2)," [", round(.lower,2),"; ",round(.upper,2),"]",sep="")) %>% 
  filter(str_detect(name,"cor_ID")==TRUE) %>% 
  mutate(response1 = case_when(
    str_detect(name,"cor_ID__adultlongevity") ~ "Adult longevity",
    str_detect(name, "cor_ID__lifetimefecundity") ~ "Fecundity",
    str_detect(name, "cor_ID__Nrappelling") ~ "Dispersal",
    str_detect(name,"cor_ID__timetomaturity") ~ "Time to maturity",
    str_detect(name,"cor_ID__sCTwidth") ~ "Body size"),
         response2 = case_when(
    str_detect(name,"adultlongevity_Intercept$") ~ "Adult longevity",
    str_detect(name, "lifetimefecundity_Intercept$") ~ "Fecundity",
    str_detect(name, "Nrappelling_Intercept$") ~ "Dispersal",
    str_detect(name,"timetomaturity_Intercept$") ~ "Time to maturity",
    str_detect(name,"sCTwidth_Intercept$") ~ "Body size"),
  ) %>% 
  select(response1,response2,value) 

##first multivar
table_cor_fullIND

## partitioned, second multivar
table_cor_MOTHER

table_cor_ID
```


### in prep for Supplementary 6: table 1a, but using the split model

```{r}
cov_mother<- VarCorr(mmod2,summary=FALSE)$MOTHER$cov
cov_ID <- VarCorr(mmod2,summary=FALSE)$ID$cov

cov_mother
cov_ID
cov_mother+cov_ID

test<- tibble(.iteration= 1:12000) %>%
  mutate(cor = map(
    .x = .iteration,
    .f = function(iter = .x, source = cov_mother+cov_ID) {
      return(source[iter, , ] %>% cov2cor())
    }
  ))


sum_cor<-tibble(y=NA,
       ymin=NA,
       ymax=NA,
       .width=NA,
       .point=NA,
       .interval=NA,
       resp1=NA,
       resp2=NA)

for(i in 1:5){
  for(j in 1:5){
    
result<-map(.x=test$cor,
    .f=function(cor=.x,x=i,y=j){return(cor[x,y])}) %>% 
  unlist() %>% 
  mean_hdi() %>% 
  mutate(resp1=row.names(test$cor[[1]])[i],
         resp2=colnames(test$cor[[1]])[j])

sum_cor<-add_row(sum_cor,result)
  }
}

print(sum_cor,n=Inf)

```




### annex what about an animal model?


```{r data-wrangling-pedigree}
# we use nadiv to get the A matrix from the pedigree

genealogy <- pedigree[c("animal","MOTHER","FATHER","sex")] %>% 
  as.data.frame() %>% 
  prepPed(gender="sex") ##why is the default name of that column "gender" in that package FFS? changed to "sex"


A<-makeA(genealogy[,1:3]) %>%  # to make the A matrix, input has to contain only ID, Dam, Sire in that order
         as.matrix() #unsparsify
```

## on errors in times esyimates

other approaches that the kind I've tried are tricky
 interval censoring could work, but only with gaussian/lognormal and no ORLE
 (trying to constrain sigma to move all variance to OLRE does not work)
 (so wa cannot use it here because we want ID correlations, and we can't easily)
 using interval censoring is tricky
 not a question of poisson, same problem if we change to lognormal
 o a way to check if our imprecision on maturity bias our conclusion would be to round/floor/ceiling times in weeks
 and see if it affects our conclusions
 using metanalysis type error is tricky too



