---
title: "Erigone project 2018 - script"
author: - "**Maxime Dahirel** (script author)"
date:
output: 
  html_document:
    theme: yeti
    toc: TRUE
    toc_float: TRUE
    code_download: TRUE
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```



## **Introduction**

The aims of this study were to:

*to add*

## **Starters and data wrangling**

*to complete*

```{r load-packages}
library(arm)
library(matrixStats)
library(ggmap)
library(ggspatial)
library(sf)
library(osmdata)
library(nadiv)

library(cmdstanr) ## Stan backend
library(brms) ## the interface we are using
library(tidyverse)
library(bayesplot)
library(tidybayes)
library(patchwork) #plotting
library(lubridate) ## conflict with here

library(here)

options(mc.cores = 4)
```


```{r}
points<-st_read(here("data","erigone2018_GISlayers.gpkg"),
        layer="sampling_sites")

patches<-st_read(here("data","erigone2018_GISlayers.gpkg"),
        layer="habitat_type")

coastline<-st_read(here("data","erigone2018_GISlayers.gpkg"),
        layer="coastline")

lon_min=-1.6802
lat_min=48.6041
lon_max=-1.4193
lat_max=48.6506

bounding_box<-opq(bbox=c(xmin=lon_min,ymin=lat_min,xmax=lon_max,ymax=lat_max))
##chosen by drawing a rectangle on OSM website

patches_updated <- patches %>% 
         filter(!is.na(plant)) %>% 
         mutate(plant=fct_relevel(plant,c("puccinellia_dominant",
                                          "puccinellia_partial"),after=0)) %>% 
         mutate(`habitat type`=fct_recode(plant,
                                        `*Puccinellia maritima* dominant` = "puccinellia_dominant",
                                        `*Puccinellia maritima* present` = "puccinellia_partial",
                                        `other unfavourable land` = "other"))

points_updated <- points %>% 
  mutate(`*E. longipalpis* found?` = fct_recode(factor(has.spider),
                                                "yes"="1",
                                                "no"="0")
  )


plot_1b <- ggplot(data = patches_updated) +
    geom_sf(aes(fill = `habitat type`,col=`habitat type`)) + 
    geom_sf(data=points_updated,aes(pch=`*E. longipalpis* found?`),size=4)+
    scale_fill_manual(values=c("#00cf3a","#afdab2",NA))+
    scale_colour_manual(values=c("#00cf3a","#afdab2",NA))+
    scale_shape_manual(values=c(21,19))+
      annotation_scale(location = "br") + # ggspatial scale on bottom left
    annotation_north_arrow(location = "tr") + # ggspatial arrow on top right
  coord_sf(xlim=c(-1.63,-1.47),
           ylim=c(48.615,48.655))+
  theme_bw()+
  theme(legend.position = "bottom",
        legend.text=element_markdown(),
        legend.title=element_markdown(),
        panel.background = element_rect(fill="lightblue"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())


plot_1a <- ggplot() +
  geom_sf(data=coastline)+
    geom_sf(data=points_updated[1,],pch=19,size=5)+
  coord_sf(xlim=c(-10.854,11.074),ylim=c(41.925,55.653))+
  theme_bw()+
  theme(
        panel.background = element_rect(fill="lightblue"),
        panel.grid.major = element_blank(),
        panel.grid.minor = element_blank())


plot_1c<-ggplot(tibble(radius=c(1:20)*100,PLAND=exp(-0.5*c(1:20))))+ ##placeholder plot for the PLAND=f(radius) plot
  geom_line(aes(radius,PLAND))+
  theme_bw()

((plot_1a+plot_1b +
  plot_layout(guides = 'collect'))&
  theme(legend.position = "bottom"))/(plot_1c) 

```



```{r}
read_csv(here("data","erigone2018_females.csv"),
                      col_types = cols(sex=col_character())) %>%  ##only females "F", if not given, will parse as logical
            filter(generation == 0) %>% 
  select(captured_on) %>% 
  distinct()

## field days are April 12, 13, May 4, May 9

## a quick confirmation of field notes that sampling was done in sunny weather
read_csv(here("data","weather_data","pontorson_meteonet_2018.csv")) %>% 
 filter(yday(date) %in% yday(ymd(c("2018-04-12","2018-04-13","2018-05-04","2018-05-09")))) %>% 
  mutate(was_sampling=hour(date)>9 & hour(date)<18) %>% #sampling was between 10pm and 5pm actually, so larger margin
 group_by(yday(date),was_sampling) %>% 
 summarise(rain=sum(precip))

## no rain indeed during sampling period
```




```{r load-raw-datafiles}
## Load raw datasets
data_main <- read_csv(here("data","erigone2018_females.csv"),
                      col_types = cols(sex=col_character())) %>%  ##only females "F", if not given, will parse as logical
            filter(generation > 0) # we only keep lab-born spiders for this analysis
## should do better, use date of birth

###NOTE to round sizes to nearest 0.1mm, with clear indication that raw-raw data are "more precise" but that's just artifact from 
## measurement software


data_mothers <- read_csv(here("data","erigone2018_females.csv"),
                      col_types = cols(sex=col_character())) %>%
            filter(generation <2) %>% 
  select(MOTHER= ID,
         CT_length1_mom = CT_length1,
         CT_length2_mom = CT_length1,
         CT_width1_mom = CT_width1,
         CT_width2_mom = CT_width2
         )

data_clutches <- read_csv(here("data","erigone2018_cocoons.csv"))

pedigree <- read_csv(here("data","erigone2018_pedigree.csv"))

sites <- read_csv(here("data","erigone2018_sites.csv"))

pairings <- read_csv(here("data","erigone2018_pairings.csv"))

## see later for environmental data, and male data
```


```{r}
pedigree %>% filter(generation>0) %>% group_by(sex) %>% count()

# counting the number of adults in the lab

sum(data_clutches$N_spiderlings) # total number of spiderlings hatched in lab


sum(sites$N_adult_females) # number of females caught total

sites %>% group_by(landscape,is_habitat) %>% 
  summarise(N_patches_with_spiders=sum(N_adult_females>0),
            N_patches_total=n())

## number of wild females that produced cocoons and babies
data_clutches %>% 
  mutate(animal=ID) %>% 
  left_join(pedigree) %>% 
  filter(generation==0) %>% 
  group_by(ID) %>% 
  summarise(had_cocoons=max(N_cocoons>0),had_babies=max(N_spiderlings>0)) %>% 
  summarise(N_with_cocoons=sum(had_cocoons),N_with_babies=sum(had_babies))
  
  
pedigree %>% filter(generation>0) %>% group_by(sex) %>% count()

# counting the number of adults in the lab


pedigree %>% group_by(sex,generation) %>% count()

pedigree %>% 
  select(MOTHER,FATHER) %>% distinct() %>% ##keep all unique MOTHER/FATHER pairs
  filter(is.na(FATHER)==FALSE) %>% 
  group_by(FATHER) %>% summarise(N_uses_per_male=length(FATHER)) %>%
  summarise(median=median(N_uses_per_male),
            mean=mean(N_uses_per_male),
            percent_more_than_one=mean(N_uses_per_male>1),
            min=min(N_uses_per_male),max=max(N_uses_per_male))
####mmm_but this is only for the ones that were kept to adults.
#### did we keep that info for the eggs???

### the version for all matings
pairings %>% 
  filter(is.na(mateID)==FALSE) %>% 
  group_by(mateID) %>% summarise(N_uses_per_male=length(mateID)) %>%
  summarise(median=median(N_uses_per_male),
            mean=mean(N_uses_per_male),
            percent_more_than_one=mean(N_uses_per_male>1),
            min=min(N_uses_per_male),max=max(N_uses_per_male))



sum(is.na(data_main$date_mating))

```


our choice of life history metrics is inspired (but not 100% identical) to Healy et al 2019 NEE:

- Age at maturity (don't forget your notes on the use of interval sampling)
- Adult longevity
- Lifetime fecundity (number of eggs, number of cocoons)
- Spread of reproduction through lifetime (to do; they use a Gini index, but their methods only really work with regular age classes, I think)

We add to that

- body size information
- dispersal information (presence/absence of dispersal-relate dbehaviours; rappelling frequencies) . Note: the original data collection plan also included information about latency to tiptoe and number of tiptoe events even if they were not followed by rappelling, but due to miscommunication on my side, the two data collectors (me and MW) did not agree on how to count tiptoes in these columns (should we count all tiptoes vs only tiptoes that were not followed by rappelling). As a result data entered in these columns is meaningless and not used or reproduced here

```{r data-wrangling-1}
fecundity <- data_clutches %>% 
  group_by(ID) %>% 
  summarise(lifetime_fecundity=sum(N_spiderlings),
            N_cocoons=sum(N_cocoons),
            N_cocoons_hatched=sum(Cocoon_hatched))


development_density <- data_clutches %>% 
  select(MOTHER=ID,
         date_egg=date_laying,
         density=N_spiderlings,
         clutch_order=clutchID)

data <- left_join(data_main,fecundity) %>%
  mutate(animal = ID) %>% 
  left_join(pedigree) %>% 
  left_join(development_density) %>% 
  mutate(lifetime_fecundity=replace_na(lifetime_fecundity,0), 
         ###individuals with no record in the fecundity are not NA, they failed to reproduce
         N_cocoons=replace_na(N_cocoons,0),
         N_cocoons_hatched=replace_na(N_cocoons_hatched,0)) %>% 
  mutate(time_to_maturity = (ymd(date_maturity)-ymd(date_hatching)) %>%  as.numeric(),
         adult_longevity = (ymd(date_death)-ymd(date_maturity)) %>%  as.numeric()
         ) %>% 
  mutate(generation = factor(generation),
         clutchID = paste(MOTHER,"-",as.character(date_egg),sep="")###wild are assumed to not be direct siblings, all count as their own clutch
  ) %>% 
  mutate(obsgap_maturity=case_when(date_maturity=="2018-05-22" | date_egg=="2018-05-22" ~ "yes",
                             wday(date_maturity,week_start=1)==1 | wday(date_egg,week_start=1)==1 ~ "yes",
                             date_maturity=="2018-05-02" | date_egg== "2018-05-02" |
                               date_maturity=="2018-05-09" | date_egg=="2018-05-09" ~ "yes",
                             T~ "no")) %>% 
  mutate(obsgap_longevity=case_when(date_maturity=="2018-05-22" | date_death=="2018-05-22" ~ "yes",
                             wday(date_maturity,week_start=1)==1 | wday(date_death,week_start=1)==1 ~ "yes",
                             date_maturity=="2018-05-02" | date_death== "2018-05-02" |
                               date_maturity=="2018-05-09" | date_death=="2018-05-09" ~ "yes",
                             T~ "no"))

## we add variables that say whether or not one of the two observations that govern phase duration
## were made right after a gap in observation (WE, holdays, other)
## leading to potential bias

```

```{r general-model-trialversion}
data$adult_censored <- (data$outlived_experiment==TRUE | data$accidental_death==TRUE)
data$time_for_repro=as.numeric(ymd(data$date_death)-ymd(data$date_mating))
data$had.mate<- (is.na(data$date_mating)==FALSE)
```

```{r}
temp_length<- data %>%
  select(ID,CT_length1,CT_length2) %>% 
  pivot_longer(cols=c(CT_length1,CT_length2),
               names_to = "size_measurement",
               names_prefix="CT_length",
               values_to="CT_length") 

temp_width<- data %>%
  select(ID,CT_width1,CT_width2) %>% 
  pivot_longer(cols=c(CT_width1,CT_width2),
               names_to = "size_measurement",
               names_prefix="CT_width",
               values_to="CT_width") 

temp_size=left_join(temp_length,temp_width)

data<-data %>% 
  select(-c(CT_length1,CT_length2,CT_width1,CT_width2)) %>% 
  left_join(temp_size) %>% 
  mutate(s_CT_width=scale(CT_width)[,1],
         s_CT_length=scale(CT_length)[,1])

```

# models

first a model for the phenotypic correlation:

```{r}

bf_size<-bf(s_CT_length |mi() ~   ## use in-model imputation
              landscape +                     ## interpatch variation, fixed component
             (1|patch)+                       ## interpatch variation, random component
             (1|r|ID),                        ## within-patch individual (co)variation
             family=gaussian)

bf_dispersal<-bf(N_rappelling | 
                   subset(size_measurement==1 & 
                            natural_death_before_dispersal==0) ~ ## data is doubled due to putting size in the "long format"
                                                 ## we only use one value per individual here, to avoid artificial doubling of N  
                   landscape + 
                   (1|patch)+
                   (1|r|ID),
                 family=poisson)

bf_devtime<-bf(time_to_maturity | 
                 subset(size_measurement==1) ~ 
                 landscape + 
                 obsgap_maturity +              ## we include this as a covariate to control whether obs gaps bias our times
             (1|patch)+
             (1|r|ID),family=poisson)

bf_longevity<-bf(adult_longevity|
                   cens(adult_censored) +   ## some individuals were not observed until the end of their natural lifespan (accidental loss/killing or outlived the experiment)
                   subset(size_measurement==1) ~ 
                   landscape + 
                   obsgap_longevity +
             (1|patch)+
             (1|r|ID),family=poisson)


bf_fecundity<-bf(lifetime_fecundity|
                   rate(time_for_repro) + ### we analysed the productivity (N offspring per day available to lay eggs)
                   subset(time_for_repro>0 & had.mate &  ## so we exclude all unmated spiders and spiders that did not have time to lay eggs
                            size_measurement==1) ~ 
                   landscape + 
             (1|patch)+
             (1|r|ID),family=poisson)

###move it to productivity with rate(time) and eliminate the delay_egg predictor (much more streamlined)

prior<-c(
  set_prior("normal(0,1)",class="Intercept",resp=c("Nrappelling","sCTlength","lifetimefecundity")),
  set_prior("normal(3.4,1)",class="Intercept",resp=c("timetomaturity","adultlongevity")),
  ### bonte pnas and duffey (longipalpis) suggest a month (exp(3.4)) is a good ballpark prior
  set_prior("normal(0,1)",class="b",resp=c("Nrappelling","lifetimefecundity","sCTlength")),
  set_prior("normal(0,1)",class="b",resp=c("timetomaturity","adultlongevity")),
  set_prior("normal(0,1)",class="sd",resp=c("Nrappelling","timetomaturity","lifetimefecundity","adultlongevity","sCTlength")),
  set_prior("lkj(3)",class="cor")
)

mod=brm(mvbf(bf_dispersal+bf_devtime+bf_fecundity+bf_longevity+bf_size),
        data=data,
        iter=6000,warmup=3000,chains=4,
        prior=prior,
        control=list(adapt_delta=0.99,max_treedepth=15),
        seed=42,
        backend="cmdstanr")
```

then a model where we split this into "relatedness + common environment" and residual (or within and among families, in the parlance of lynch walsh):

we cannot go further and include father info since it is missing for G1, and we cannot assume that wild caught females only mated with one male (which would allow us to add these phantom males to the pedigree) since there is indication that erigone females mate multiple times (anecdote in de meester bonte 2010 among others,see also Comparative  study  of  courtship  and  copulation  in  fiveOedothorax species)

```{r}


             
bf_size<-bf(s_CT_length |mi() ~   ## use in-model imputation
              landscape +                     ## interpatch variation, fixed component
             (1|patch)+                       ## interpatch variation, random component
              (1|q|MOTHER)+
             (1|r|ID),                        ## within-patch individual (co)variation
             family=gaussian)

bf_dispersal<-bf(N_rappelling |
                   subset(size_measurement==1 & 
                            natural_death_before_dispersal==0) ~ ## data is doubled due to putting size in the "long format"
                                                 ## we only use one value per individual here, to avoid artificial doubling of N  
                   landscape + 
                   (1|patch)+
                   (1|q|MOTHER)+
                   (1|r|ID),
                 family=poisson)

bf_devtime<-bf(time_to_maturity | 
                 subset(size_measurement==1) ~ 
                 landscape + 
                 obsgap_maturity +              ## we include this as a covariate to control whether obs gaps bias our times
             (1|patch)+
               (1|q|MOTHER)+
             (1|r|ID),family=poisson)

bf_longevity<-bf(adult_longevity|
                   cens(adult_censored) +   ## some individuals were not observed until the end of their natural lifespan (accidental loss/killing or outlived the experiment)
                   subset(size_measurement==1) ~ 
                   landscape + 
                   obsgap_longevity +
             (1|patch)+
               (1|q|MOTHER)+
             (1|r|ID),family=poisson)


bf_fecundity<-bf(lifetime_fecundity|
                   rate(time_for_repro) + ### we analysed the productivity (N offspring per day available to lay eggs)
                   subset(time_for_repro>0 & had.mate &  ## so we exclude all unmated spiders and spiders that did not have time to lay eggs
                            size_measurement==1) ~ 
                   landscape + 
             (1|patch)+
               (1|q|MOTHER)+
             (1|r|ID),family=poisson)

###move it to productivity with rate(time) and eliminate the delay_egg predictor (much more streamlined)

prior<-c(
  set_prior("normal(0,1)",class="Intercept",resp=c("Nrappelling","sCTlength","lifetimefecundity")),
  set_prior("normal(3.4,1)",class="Intercept",resp=c("timetomaturity","adultlongevity")),
  ### bonte pnas and duffey (longipalpis) suggest a month (exp(3.4)) is a good ballpark prior
  set_prior("normal(0,1)",class="b",resp=c("Nrappelling","lifetimefecundity","sCTlength")),
  set_prior("normal(0,1)",class="b",resp=c("timetomaturity","adultlongevity")),
  set_prior("normal(0,1)",class="sd",resp=c("Nrappelling","timetomaturity","lifetimefecundity","adultlongevity","sCTlength")),
  set_prior("lkj(3)",class="cor")
)

mod2=brm(mvbf(bf_dispersal+bf_devtime+bf_fecundity+bf_longevity+bf_size),
        data=data,
        iter=6000,warmup=3000,chains=4,
        prior=prior,
        control=list(adapt_delta=0.99,max_treedepth=20),
        seed=42,
        backend="cmdstanr")

```

we find that most of the syndrome is driven by within-family variation (something that would not have been visible from the attempt at doing an animal model)











### about the fig 1

```{r}
###recalculate the pland at different scales within R then do something inspired by this
###here test is the file with PLANDS fro mMarie

data %>% select(patch,landscape) %>% distinct() %>% right_join(test) %>% select(-c(effort,nbre_visit)) %>% filter(!is.na(landscape)) %>% pivot_longer(cols=-c(patch,landscape),names_prefix="PLAND_",names_to="radius",values_to="PLAND") %>% mutate(radius=as.numeric(radius)) %>% ggplot()+geom_line(aes(radius,PLAND,col=landscape,group=patch))
```








### annex what about an animal model?


```{r data-wrangling-pedigree}
# we use nadiv to get the A matrix from the pedigree

genealogy <- pedigree[c("animal","MOTHER","FATHER","sex")] %>% 
  as.data.frame() %>% 
  prepPed(gender="sex") ##why is the default name of that column "gender" in that package FFS? changed to "sex"


A<-makeA(genealogy[,1:3]) %>%  # to make the A matrix, input has to contain only ID, Dam, Sire in that order
         as.matrix() #unsparsify
```

## on errors in times esyimates

other approaches that the kind I've tried are tricky
 interval censoring could work, but only with gaussian/lognormal and no ORLE
 (trying to constrain sigma to move all variance to OLRE does not work)
 (so wa cannot use it here because we want ID correlations, and we can't easily)
 using interval censoring is tricky
 not a question of poisson, same problem if we change to lognormal
 o a way to check if our imprecision on maturity bias our conclusion would be to round/floor/ceiling times in weeks
 and see if it affects our conclusions
 using metanalysis type error is tricky too
```{r}
bf_size<-bf(s_CT_length |mi() ~   ## only use actually measured spiders, exclude the NAs/the dummies put in their places
              landscape +                     ## interpatch variation, fixed component
             (1|patch)+                       ## interpatch variation, random component
             (1|r|ID),                        ## within-patch individual (co)variation
             family=gaussian)

prior<-c(
  set_prior("normal(0,1)",class="Intercept"),
  set_prior("normal(0,1)",class="b"),
  set_prior("normal(0,1)",class="sd")
)

mod2=brm(bf_size,
        data=data,
        iter=2000,warmup=1000,chains=4,
        prior=prior,
        control=list(adapt_delta=0.99,max_treedepth=20),
        seed=42,
        backend="cmdstanr")

```



